const XmlToJson=(function(){let self=this;self.isType=(data)=>{let dataType=Object.prototype.toString.call(data).slice(8,-1);return isType=>isType.toLowerCase()===dataType.toLowerCase();}
self.convertKey=(obj,keyMap,isDeep)=>{if(!['[object Array]','[object Object]'].includes(Object.prototype.toString.call(obj))){throw new TypeError('The first argument should be either an object or an array！');}
if(Object.prototype.toString.call(keyMap)!=='[object Object]'){throw new TypeError('The parameter keyMap should be an object!');}
let res=obj instanceof Array?[]:{};if(obj instanceof Object){for(let key in obj){let newKey=Object.keys(keyMap).includes(key)?keyMap[key]:key;res[newKey]=obj[key];if(isDeep&&obj[key]instanceof Object&&Object.keys(obj[key]).length){res[newKey]=self.convertKey(obj[key],keyMap,isDeep);}}}
return res;}
self.convertXMLStringToDoc=xmlString=>{let xmlDoc=null;if(window.DOMParser){let parser=new DOMParser();xmlDoc=parser.parseFromString(xmlString,"text/xml");}else{xmlDoc=new ActiveXObject("Microsoft.XMLDOM");xmlDoc.async="false";xmlDoc.loadXML(xmlString);}
return xmlDoc;}
self.queryNodeAttrs=node=>{if(!node.hasAttributes||!node.hasAttributes())return{};let attrs={};const len=node.attributes.length;for(let i=0;i<len;i++){let it=node.attributes[i];attrs[it.name]=it.value;}
return attrs;}
self.parse=(xmlString,conf)=>{if(xmlString&&typeof xmlString!=='string'){throw new TypeError('The first argument should be a string!');}
if(conf&&!self.isType(conf)('object')){throw new TypeError('The parse configuration should be an object!')}
try{self.conf=conf;let{jsonString,conversionkeyMap}=conf;let xmlDocNodes=self.convertXMLStringToDoc(xmlString);let nodes=self.parseNode({},xmlDocNodes.firstChild);if(conversionkeyMap&&self.isType(conversionkeyMap)('object')){nodes=self.convertKey(nodes,conversionkeyMap,true);}
return jsonString?JSON.stringify(nodes):nodes;}catch(error){console.log(error);return null;}}
self.parseNode=(parent,node)=>{let{conf,parseValue,addToParent}=self;let obj={...self.queryNodeAttrs(node)};let{nodeName}=node;if(node.childNodes.length===1&&node.childNodes[0].nodeType===3){if(node.hasAttributes()){obj[conf.textKey]=parseValue(node.childNodes[0].nodeValue);}else{obj=parseValue(node.childNodes[0].nodeValue)}}
else{self.parseChildren(obj,node.childNodes);}
addToParent(parent,nodeName,obj);return parent;}
self.parseValue=(val)=>{try{let num=Number(val);if(val.toLowerCase()==='true'||val.toLowerCase()==='false'){return val.toLowerCase()==='true';}else if(isNaN(num)){return val.trim();}else{return num;}}catch(error){return val;}}
self.parseChildren=(resJson,childNodes)=>{if(childNodes.length){for(let i=0;i<childNodes.length;i++){if(childNodes[i].nodeType===1){self.parseNode(resJson,childNodes[i]);}}}}
self.addToParent=(parent,nodeName,obj)=>{if(!parent[nodeName]){parent[nodeName]=obj;}else{if(!Array.isArray(parent[nodeName])){let temp=parent[nodeName];parent[nodeName]=[];parent[nodeName].push(temp)}
parent[nodeName].push(obj);}}
return{parse:function(xmlStr,conf){let parseData=self.parse(xmlStr,conf);return parseData;}}})()